# race-strat-sim
This repository contains a Java Project focussed on building a Motorsports Race Strategy Tool

# Overview

Success in Motorsports hinges on car performance, team operations and key decisions made on track over a race weekend. Some of the most important decisions to achieve a strong result are Race Strategy decisions made during a Race Session and these can make or break the team’s race weekend irrespective of how strong their car is performing.

The project that I have developed is a Motorsports Race Strategy Simulation application developed in Java. The idea behind this application is to maximize a driver’s and subsequently a team’s race result by processing drivers’ race lap times from a data set - this could be a CSV file or a Text file - and generate the optimum strategic decision in real-time for a selected driver. Databases such as MySQL and MongoDB are used to store the lap times and the strategy that is ultimately chosen by the user. The key is to develop a comprehensive tool that is extremely robust in terms of inputs, scalability, updating of features, but most importantly: numerous considerations that apply to the Race Session.

There are several, critical factors taken into account while determining the optimum strategy; such as the inclement weather (dynamic), tyre compound/longevity/delta/offset, tyre warm up, track layout, track temperature/evolution, anticipated degradation (fuel consideration), safety car probability, opponent’s car(s), likelihood of being overtaken, average finishing position, pitlane time loss, rejoining position, risk vs reward (two alternatives), and laps remaining. Ultimately, it is intuition that goes hand in hand with the data and the element of intuition is strongly applied in this Race Strategy Simulation application and this will become apparent due to the nature of the strategic decisions.

The app begins by prompting the user to input the key variables for that Race Session or these can be generated by choosing to randomize the variables. Once the variables have been determined and the simulation has been ‘started’ it begins visualizing the respective lap times, current track position and time interval between drivers over a race distance. It utilizes the aforementioned variables to generate a pre-race strategy; however, it does adjust the pre-determined strategy on the fly and prompts the team to “box” depending on how the race unfolds. The Strategy Simulation tool is quite dynamic as it also suggests possibly extending the current stint length to benefit from track position in certain scenarios.

For the moment, the functionality of this application is limited to the Race Session, however, in future there may be a separate tab (or a separate application altogether) that operates for the Qualifying Session as well, because maximizing the conditions and a clear track in Qualifying plays a significant role in determining the driver’s grid position for the race and subsequently influences the race strategy as well.

Given that I do not have any exposure to the tools and software that Motorsports teams have at their disposable, I cannot compare my application to the industry standard software. I would assume that it is a very basic and superficial form of the ultra-intricate, secure, robust, complex and data-rich tools that are used in the Motorsports industry, where live data is received directly from the cars, weather is accurately forecasted and experienced Race Engineers and Team Personnel would make more optimum strategic decisions based on a wealth of on-track experience that I do not have and certainly do not try and compare with.

The purpose of this tool is simply to demonstrate my understanding of racing dynamics as a Motorsports enthusiast since the age of 12 and the Software Development skills that go along with it, as I seek employment within the industry and wish to learn from some of the best minds in the world.


# Software Design Patterns

Here are some of the design patterns I have used in my project

1. Singleton Pattern:

This is used in the Degradation Class so that it ensures there is only one instance of tyreDeg being created during the running of this program.
Initially, there was a new tyreDeg value being generated at every lap and this is wrong. Now, with the Singleton Pattern the same
tyreDeg is being used on all laps from lap 2 onwards. Therefore, it brings more consistency and a more sensible project. Thus, it was necessary.


2. Factory Method Pattern and Builder Pattern:

I used the Factory Method and Builder pattern in the Circuits, CircuitFactory and CircuitBuilder Classes so that a circuit object is created
while abstracting the creation logic, but also, it significantly cleaned up my code from what my original Circuit class looked like.
Now, there arent tonnes of switch statements that are restricted only to the Circuit class to display information, instead, in conjunction with the Builder Pattern,
I am able to further utilize the circuit characteristics throughout my code. The Builder pattern plays the role of step by step
building specific circuit characteristics which are being created with the circuit object in the factory method pattern.
I also have a circuit interface which can be used for specific statements about the track but i have not used it yet.


4. Strategy Pattern:

This pattern was used, unsurprisingly, in the generation of race strategies. The originally 'Strategies' class (which i have left here for reference)
was clunky and restrictive. It has now been broken into respective strategy classes named after their purpose.


Conclusion:


All in all, while this approach resulted in more classes and interfaces, it allowed for my code to be more readable, maintainable,
improved extensibility, and allowed for the code to be more flexible in use around the program.

# Class Relationships

This section will contain information about the relationships between classes and interfaces

# Code Complexity

I intend to keep the complexity low but effective, and yet demonstrate some prowess. Possibly use some unique code implementations/tools.

Can possibly use a system to measure time, memory and energy usage (later).

This is currently a base model of a Race Strategy Simulator. In future, I can implement a more comprehensive model for the tyres, current tyres, individual tyre degradation, dynamic pitstop lap generation etc.

Since this was a personal project developed during my intense Master's Program, I may also include a GUI for this program in future.

# Code Maintainability, Readability and Reusability

Code should be loosely coupled. Should be able to demonstrate the addition of code/variables, reuse older code (such as reader),
The code should be well segmented, naming conventions. Minimize smells.

